HTTPS 协议是由 HTTP 加上 TLS/SSL 协议构建的可进行加密传输、身份认证的网络协议，主要通过数字证书、加密算法、非对称密钥等技术完成互联网数据传输加密，实现互联网传输安全保护。

设计目标主要有三个:

1. 数据保密性：保证数据内容在传输的过程中不会被第三方查看。就像快递员传递包裹一样，都进行了封装，别人无法获知里面装了什么。
2. 数据完整性：及时发现被第三方篡改的传输内容。就像快递员虽然不知道包裹里装了什么东西，但他有可能中途掉包，数据完整性就是指如果被掉包，我们能轻松发现并拒收。
3. 身份校验安全性：保证数据到达用户期望的目的地。就像我们邮寄包裹时，虽然是一个封装好的未掉包的包裹，但必须确定这个包裹不会送错地方，通过身份校验来确保送对了地方。


证书可以使用自己生成，也可以向专门的https证书提供商进行购买。这两种的区别是自己生成的证书是不被浏览器信任的,所以当访问的时候回提示不安全的网站，需要点击信任之后才能继续访问，而购买的https证书会提示安全

### 接口请求过程


### RSA

### sha256

### 证书的作用？

证书的作用是什么，直接对http加密不就可以了吗？而且证书任何单位都可以申请



浏览器中预置了一些https证书提供商的证书，在浏览器获取到服务器的https证书进行验证的时候就知道这个https证书是可信的；而自己生成的证书，浏览器获取到之后无法进行验证是否可信，所以就给出不安全的提示。只能验证顶级域名，一层一层验证，顶层由浏览器验证？


能够确认的事情



### 证书申请过程

1. 向CA机构提交申请信息：

    - 公司信息
    - 加密算法（RSA）
    - Hash签名算法（sha256）
    - 加密位数
    - 域名

2. CA机构收到证书申请

    - 使用申请的Hash算法，对证书内容进行摘要
    - 使用CA机构自己的RSA私钥对这段摘要信息进行签名

3. CA机构把签名过的证书通过邮件形式发送给申请者

### https 连接过程

1. 客户端发送Client Hello给服务端，包含以下信息：
    - 支持的TLS版本
    - 支持的加密方式（如RSA）
    - 随机数
    - Session ID
    - 客户端的当前时间
    - 域名

2. 服务端发送server Hello
    - 确定TLS版本
    - 随机数
    - 确定加密方式(ECDHE,RSA,AES,SHA256)
        * ECDHE：用于生成证书的密钥和公钥
        * RSA：验证证书（对公钥签名）
        * AES：数据传输加密方法，利用主密钥生产另一个密钥
        * SHA256：检验数据是否合法
    - 证书

    - 时间
    - Session ID

3. 客户端：
    - 验证证书

        - 颁发证书的CA机构的RSA公钥预置在操作系统中，浏览器就可以使用CA机构的公钥对服务器的证书进行验签，确定证书是不是由正规的CA机构颁发（怎么判断是不是由正规的CA机构颁发）。
        - 验签之后得到证书摘要。客户端使用sha256对证书内容进行摘要，然后和验签后的证书摘要进行比较，如果相等说明证书没有被修改过。（干嘛要改证书，改证书的意义是什么？）

    - 生成随机数

        - 验证通过后，客户端生成随机数，然后用证书中的公钥进行加密，发送给服务端

4. 服务端

    - 服务端使用密钥对加密的随机数进行解密，获取随机数
    - 根据解密后的随机数，客户端第一次请求发给服务端的随机数，以及服务端第一次响应发给客户端的随机数，生成session key和mac算法密钥。
    - 根据session key和mac算法密钥对传输内容进行加密，再发送给客户端。具体加密过程：

        - mac密钥对内容进行摘要
        - 再用session key对摘要进行加密

5. 客户端

    - 客户端接收到服务端的数据后，先使用server_write_key进行解密（server_wirte_key怎么来的）
    - 再用server_write_MAC_key对数据完整性进行验证。（server_write_MAC_key怎么来的）



6. 服务端

    - 服务端接收到客户端的数据后，先使用client_write_key进行解密（client_write_key怎么来的）
    - 再用client_write_MAC_key对数据完整性进行验证。（client_write_MAC_key怎么来的）

4. 

4. 密钥交换 
    - Server Key Exchanger，发送公钥（用客户端的公钥（RSA）签名过的）给客户端，需要客户端的密钥才能解密
    - Client Key Exchanger，利用服务端发送的随机密码生成主密钥，然后发送公钥（用服务端公钥签名过的）给服务端，

5. 服务端确认，会ACK,开始传输数据 

### 证书

1. 服务器的证书有对应的密钥（d,n）和公钥(e,n)，满足这个条件

```javascript
EM = M ^ e % n; //加密：M内容，EM加密结果
M = EM ^ d % n; //解密：EM解密内容，M解密结果
```
2. 服务器发送的证书包含这些信息：

    - 签名：用证书的密钥对被签名的证书做的签名
    - 签名算法：例如RSA + SHA256
    - 被签名的证书（tbsCertificate）
        * 申请时的组织信息
        * 有效期
        * 当前证书的公钥

3. 证书的签名是用证书的密钥对tbsCertificate(被签名的证书)做的加密，并添加了防篡改标识。
4. 签名算法包括对tbsCertificate(被签名的证书）加解密算法和防篡标识计算算法（RSA证书加解密算法，SHA256防篡改计算算法）。
5. 服务器发送的证书的公钥存在被签名的证书信息里面。
6. 客户端收到证书后利用公钥对签名进行解密，并对被签名的证书(tbsCertificate)做防篡改计算，计算结果和解密后的防篡改标识比对，一样则没有被篡改,反之则被篡改。

> 服务端选择的加密方式：ECDHE(),RSA()