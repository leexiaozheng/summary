> html：
```html
<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8"/>
    <title>组件页面渲染的基本过程</title>
</head>
<body>
    <div id="app"></div>
</body>
</html>
```
> main.js：

```javascript
import Vue from "vue";
import Home from "./home.vue";

new Vue({
    el: "#app",
    template: "<Home/>",
    components: { Home }
});
```

> home.vue
```html
<template>
    <div class="home">
        <a>{{text}}</a>
    </div>
</template>
<script>
    export default {
        name: "home",
        data() {
            return {
                text: '测试'
            };
        },
        mounted() {
            
        },
        methods: {
        }
    };
</script>
```
1.项目运行编译时，home.vue中的template会被vue-loader编译成render函数，作为vue文件中的对象的方法。组件通过components引用该组件对象，创建组件实例，渲染组件页面(多个组件引用同一组件时，引用的是相同的对象，解释data为什么要是函数)。main.js根组件template转化成render函数是由vue插件中的编译器实现的。

```javascript
// 编译器生成的render函数：
var render = function() {
    var _vm = this
    var _h = _vm.$createElement
    var _c = _vm._self._c || _h
    return _c(
        "div",
        { staticClass: "home" },
        [
            _c("a",
                [_vm._v(_vm._s(_vm.text))]
            )
        ]
    )
}
```

```javascript
// 编译后的组件对象:
{
    beforeCreate: []
    beforeDestroy: []
    data: function() {}
    methods: {}
    mounted: function() {}
    name: "home"
    render: function() {}
    staticRenderFns: []
    __file: "src/page/home/index.vue"
    _compiled: true
}
```

2.组件渲染页面时会先调用render函数，render函数返回组件的节点（文中的节点是指VNode的实例）信息。render函数包含组件模板内的标签信息，每个标签(包括文本和组件标签等)会创建一个节点。先创建子标签的节点，在创建父标签的节点时,将它添加父节点的children数组中，形成与标签结构相同的树形结构。


```javascript
// VNode节点构造函数
var VNode = function VNode (
    tag,
    data,
    children,
    text,
    elm,
    context,
    componentOptions,
    asyncFactory
) {
    this.tag = tag;// 标签名
    this.data = data;// 节点数据,包括节点的生命周期函数
    this.children = children;// 创建原生标签节点实例时保存的子节点
    this.text = text;// 为文本节点或者注释节点时的文本内容
    this.elm = elm;// 节点对应的DOM元素引，如果是组件节点为组件根DOM元素的引用
    this.ns = undefined;
    this.context = context;// 标签所在组件的实例
    this.fnContext = undefined;
    this.fnOptions = undefined;
    this.fnScopeId = undefined;
    this.key = data && data.key;// key
    this.componentOptions = componentOptions;// 缓存组件标签信息，包括组件名称，组件选项、标签上的props、标签上的事件、以及子节点。
    this.componentInstance = undefined;// 节点对应的组件实例，只有组件标签节点才有组件实例，DOM节点无组件实例
    this.parent = undefined;// 组件模板中的根标签节点才有该值，指向标签所在的组件节点
    this.raw = false;
    this.isStatic = false;
    this.isRootInsert = true;
    this.isComment = false;// 是否是注释节点
    this.isCloned = false;
    this.isOnce = false;
    this.asyncFactory = asyncFactory;
    this.asyncMeta = undefined;
    this.isAsyncPlaceholder = false;
};
```

```javascript
// 调用render函数，生成组件模板对应的节点
Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var _parentVnode = ref._parentVnode;
    ...
    vm.$vnode = _parentVnode;
    // render self
    var vnode;
    ...
    currentRenderingInstance = vm;
    vnode = render.call(vm._renderProxy, vm.$createElement);//返回VNode节点实例
    ...
    currentRenderingInstance = null;
    ...
    vnode.parent = _parentVnode;// 设置组件根标签VNode实例的parent为当前组件VNode实例。
    return vnode
};
```
```javascript
// 根据标签创建节点
function _createElement (
  context,
  tag,
  data,
  children,
  normalizationType
) {
    if (isDef(data) && isDef((data).__ob__)) {
        ...
        return createEmptyVNode()
    }
    ...
    if (!tag) {
        return createEmptyVNode()
    }
    ...
    if (typeof tag === 'string') {
        vnode = new VNode(
            config.parsePlatformTagName(tag), data, children,
            undefined, undefined, context
        );
        } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {/* 从组件实例option的components中寻找该组件标签信息（组件对象） */
        vnode = createComponent(Ctor, data, context, children, tag);// 组件标签节点
        } else {
        vnode = new VNode(
            tag, data, children,
            undefined, undefined, context
        );
        }
    } else {
        vnode = createComponent(tag, data, context, children);// 标签节点
    }
    if (Array.isArray(vnode)) {
        return vnode
    } else if (isDef(vnode)) {
        if (isDef(ns)) { applyNS(vnode, ns); }
        if (isDef(data)) { registerDeepBindings(data); }
        return vnode
    } else {
        return createEmptyVNode()
    }
}
```
3.如果标签是组件标签，通过components找到的组件信息（vue文件中的组件对象），并使用extend方法生成组件的构造函数，将构造函数和组件信息保存在组件标签生成的节点上。

4.render函数生成组件模板对应的节点树，并设置根节点的parent指向当前组件节点。将节点作为新节点，传入到patch方法中，组件页面初始更新时，不存在旧节点，直接根据新节点创建DOM。

```javascript
// 组件页面更新
Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var restoreActiveInstance = setActiveInstance(vm);
    vm._vnode = vnode;
    ...
    if (!prevVnode) {// 组件初始渲染
    // initial render
        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);// 将patch后组件根DOM元素赋值给实例的$el属性
    } else {
    // updates
        vm.$el = vm.__patch__(prevVnode, vnode);// 将patch后组件根DOM元素赋值给实例的$el属性
    }
    restoreActiveInstance();
    ...
  };
```

5.在patch方法中，根据节点信息创建DOM元素，并在节点上保存它的DOM元素,再获取节点的children属性值，创建子节点的DOM元素，并添加到父元素中，完成组件的渲染。

```javascript
// 根据节点类型（标签类型），创建组件实例或者DOM元素
function createElm (
    vnode,
    insertedVnodeQueue,
    parentElm,
    refElm,
    nested,
    ownerArray,
    index
  ) {
   ...
    vnode.isRootInsert = !nested; // for transition enter check
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {// 如果vnode是组件节点，创建组件实例
      return
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    if (isDef(tag)) {
      ...
      vnode.elm = vnode.ns // 创建DOM元素
        ? nodeOps.createElementNS(vnode.ns, tag)
        : nodeOps.createElement(tag, vnode);
      setScope(vnode);// 添加DOM属性，构造css作用域
      {
        createChildren(vnode, children, insertedVnodeQueue);// 创建子节点的DOM元素
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }
        insert(parentElm, vnode.elm, refElm);// 添加DOM元素
      }
        ...
    } else if (isTrue(vnode.isComment)) {// 注释节点
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);// 添加DOM元素
    } else {// 文本节点
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);// 添加DOM元素
    }
  }
```

6.如果节点包含组件构造器信息（节点是组件节点），会先使用构造器创建组件实例，调用组件render方法，执行以上操作，生成组件模板对应的节点树，根据节点生成DOM元素，并将根节点的DOM元素保存在组件上，然后添加到父级DOM元素上，完成组件的渲染。

```javascript
// 生成组件实例，并添加组件上的根DOM元素到父级DOM素中：
function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;
    if (isDef(i)) {
        var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
        if (isDef(i = i.hook) && isDef(i = i.init)) {
            i(vnode, false /* hydrating */);// 调用节点生命周期函数init，生成组件实例
        }
        // after calling the init hook, if the vnode is a child component
        // it should've created a child instance and mounted it. the child
        // component also has set the placeholder vnode's elm.
        // in that case we can just return the element and be done.
        if (isDef(vnode.componentInstance)) {
            initComponent(vnode, insertedVnodeQueue);
            insert(parentElm, vnode.elm, refElm);// 组件对应的根DOM元素添加到父级DOM元素中
            if (isTrue(isReactivated)) {
            reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
            }
            return true
        }
    }
}
```

```javascript
// 在节点生命周期init创建组件实例
function init (vnode, hydrating) {
    ...
    var child = vnode.componentInstance = createComponentInstanceForVnode(
    vnode,
    activeInstance// 当前更新组件实例，也就是父组件实例
    );// 创建组件实例
    child.$mount(hydrating ? vnode.elm : undefined, hydrating);//渲染组件页面
}  
```